#!/bin/bash
# ============================================
# Prewarm CLI - Queue Management
# ============================================

set -e

# Configuration
PREWARM_DIR="/var/lib/prewarm"
QUEUE_DIR="$PREWARM_DIR/queue"
RUNNING_DIR="$PREWARM_DIR/running"
COMPLETED_DIR="$PREWARM_DIR/completed"
LOG_DIR="$PREWARM_DIR/logs"
PID_FILE="$PREWARM_DIR/daemon.pid"
CONFIG_FILE="$PREWARM_DIR/config"
WORKER_SCRIPT="$(dirname "$0")/prewarm-worker.sh"

# Default config
MAX_CONCURRENT=2
DEFAULT_PARALLEL=20
BASE_DOMAIN=""
API_ENDPOINT=""
API_TOKEN=""

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

# Initialize directories
init_dirs() {
    mkdir -p "$QUEUE_DIR" "$RUNNING_DIR" "$COMPLETED_DIR" "$LOG_DIR"
    
    # Create default config if not exists
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "MAX_CONCURRENT=$MAX_CONCURRENT" > "$CONFIG_FILE"
        echo "DEFAULT_PARALLEL=$DEFAULT_PARALLEL" >> "$CONFIG_FILE"
        echo "BASE_DOMAIN=" >> "$CONFIG_FILE"
        echo "API_ENDPOINT=" >> "$CONFIG_FILE"
        echo "API_TOKEN=" >> "$CONFIG_FILE"
    fi
    
    # Load config
    source "$CONFIG_FILE"
}

# Generate random ID
generate_id() {
    cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 6 | head -n 1
}

# Get current timestamp
timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Send stats to API endpoint
send_stats() {
    local job_file="$1"
    
    if [ -z "$API_ENDPOINT" ]; then
        return 0
    fi
    
    local id=$(grep -o '"id": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local url=$(grep -o '"url": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local total=$(grep -o '"total": [0-9]*' "$job_file" | awk '{print $2}')
    local hit=$(grep -o '"hit": [0-9]*' "$job_file" | awk '{print $2}')
    local miss=$(grep -o '"miss": [0-9]*' "$job_file" | awk '{print $2}')
    local expired=$(grep -o '"expired": [0-9]*' "$job_file" | awk '{print $2}')
    local failed=$(grep -o '"failed": [0-9]*' "$job_file" | awk '{print $2}')
    local started=$(grep -o '"started": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local completed=$(grep -o '"completed": "[^"]*"' "$job_file" | cut -d'"' -f4)
    
    local auth_header=""
    if [ -n "$API_TOKEN" ]; then
        auth_header="-H \"Authorization: Bearer $API_TOKEN\""
    fi
    
    # Send POST request with stats
    curl -s -X POST "$API_ENDPOINT/complete" \
        -H "Content-Type: application/json" \
        $auth_header \
        -d "{
            \"job_id\": \"$id\",
            \"url\": \"$url\",
            \"total\": $total,
            \"hit\": ${hit:-0},
            \"miss\": ${miss:-0},
            \"expired\": ${expired:-0},
            \"failed\": ${failed:-0},
            \"started\": \"$started\",
            \"completed\": \"$completed\"
        }" > /dev/null 2>&1 || true
}

# Fetch queue from API endpoint
fetch_queue() {
    if [ -z "$API_ENDPOINT" ]; then
        return 0
    fi
    
    local auth_header=""
    if [ -n "$API_TOKEN" ]; then
        auth_header="-H \"Authorization: Bearer $API_TOKEN\""
    fi
    
    # Fetch from API
    local response=$(curl -s -X GET "$API_ENDPOINT/queue" \
        -H "Content-Type: application/json" \
        $auth_header 2>/dev/null || echo "")
    
    if [ -z "$response" ]; then
        return 0
    fi
    
    # Parse JSON array and add jobs
    # Expected format: [{"id": "xxx", "parallel": 20}, ...]
    echo "$response" | grep -oP '\{"id":\s*"[^"]+",\s*"parallel":\s*[0-9]+\}' | while read -r job; do
        local job_id=$(echo "$job" | grep -oP '"id":\s*"\K[^"]+')
        local parallel=$(echo "$job" | grep -oP '"parallel":\s*\K[0-9]+')
        
        if [ -n "$job_id" ]; then
            # Add job silently
            cmd_add "$job_id" "${parallel:-$DEFAULT_PARALLEL}" 2>/dev/null || true
        fi
    done
}

# Check and fetch queue if empty
check_and_fetch_queue() {
    local pending_count=$(ls -1 "$QUEUE_DIR"/*.job 2>/dev/null | wc -l)
    local running_count=$(ls -1 "$RUNNING_DIR"/*.job 2>/dev/null | wc -l)
    
    if [ "$pending_count" -eq 0 ] && [ "$running_count" -eq 0 ]; then
        fetch_queue
    fi
}

# ============================================
# Commands
# ============================================

# Setup command
cmd_setup() {
    echo -e "${BOLD}${CYAN}══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}Prewarm CLI Setup${NC}"
    echo -e "${CYAN}══════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Base Domain
    echo -e "${BOLD}Base Domain${NC}"
    echo -e "  ใช้สำหรับสร้าง URL อัตโนมัติจาก ID"
    echo -e "  Example: media.vdohls.com"
    echo -e "  ID h_A8yW-KTJql3 → https://media.vdohls.com/h_A8yW-KTJql3/playlist.m3u8"
    echo ""
    read -p "Base Domain [$BASE_DOMAIN]: " input_domain
    BASE_DOMAIN="${input_domain:-$BASE_DOMAIN}"
    
    echo ""
    
    # API Endpoint
    echo -e "${BOLD}API Endpoint${NC}"
    echo -e "  เมื่อ job เสร็จ จะส่งสถิติไป endpoint นี้"
    echo -e "  เมื่อ queue ว่าง จะดึง job ใหม่จาก endpoint นี้"
    echo -e "  Example: https://api.example.com/prewarm"
    echo ""
    read -p "API Endpoint [$API_ENDPOINT]: " input_endpoint
    API_ENDPOINT="${input_endpoint:-$API_ENDPOINT}"
    
    echo ""
    
    # API Token (optional)
    echo -e "${BOLD}API Token${NC} (optional)"
    echo -e "  ใช้สำหรับ Authorization header"
    echo ""
    read -p "API Token [$API_TOKEN]: " input_token
    API_TOKEN="${input_token:-$API_TOKEN}"
    
    # Save config
    cat > "$CONFIG_FILE" << EOF
MAX_CONCURRENT=$MAX_CONCURRENT
DEFAULT_PARALLEL=$DEFAULT_PARALLEL
BASE_DOMAIN=$BASE_DOMAIN
API_ENDPOINT=$API_ENDPOINT
API_TOKEN=$API_TOKEN
EOF
    
    echo ""
    echo -e "${GREEN}✓ Configuration saved${NC}"
    echo ""
    echo -e "${BOLD}Current Settings:${NC}"
    echo -e "  BASE_DOMAIN:    $BASE_DOMAIN"
    echo -e "  API_ENDPOINT:   $API_ENDPOINT"
    echo -e "  API_TOKEN:      ${API_TOKEN:+***hidden***}"
}

# Check if URL already exists in queue or running
check_duplicate_url() {
    local url="$1"
    local existing_id=""
    
    # Check queue
    shopt -s nullglob
    for job_file in "$QUEUE_DIR"/*.job "$RUNNING_DIR"/*.job; do
        [ -f "$job_file" ] || continue
        local job_url=$(grep -o '"url": "[^"]*"' "$job_file" | cut -d'"' -f4)
        if [ "$job_url" = "$url" ]; then
            existing_id=$(grep -o '"id": "[^"]*"' "$job_file" | cut -d'"' -f4)
            break
        fi
    done
    shopt -u nullglob
    
    echo "$existing_id"
}

cmd_add() {
    local input="$1"
    local parallel="${2:-$DEFAULT_PARALLEL}"
    local force=false
    local url=""
    
    # Check for -f/--force flag
    if [ "$1" = "-f" ] || [ "$1" = "--force" ]; then
        force=true
        input="$2"
        parallel="${3:-$DEFAULT_PARALLEL}"
    fi
    
    if [ -z "$input" ]; then
        echo -e "${RED}Error: URL or ID is required${NC}"
        echo "Usage: prewarm add <url|id> [parallel]"
        echo "       prewarm add -f <url|id> [parallel]  # Force add (skip duplicate check)"
        echo ""
        echo "Examples:"
        echo "  prewarm add https://example.com/master.m3u8"
        echo "  prewarm add h_A8yW-KTJql3              # Uses BASE_DOMAIN to build URL"
        exit 1
    fi
    
    # Check if input is URL or ID
    if [[ "$input" =~ ^https?:// ]]; then
        # It's a full URL
        url="$input"
    else
        # It's an ID - build URL from BASE_DOMAIN
        if [ -z "$BASE_DOMAIN" ]; then
            echo -e "${RED}Error: BASE_DOMAIN not configured${NC}"
            echo "Run 'prewarm setup' first or provide full URL"
            exit 1
        fi
        url="https://$BASE_DOMAIN/$input/playlist.m3u8"
        echo -e "${DIM}Building URL: $url${NC}"
    fi
    
    # Check for duplicate URL
    if [ "$force" = false ]; then
        local existing_id=$(check_duplicate_url "$url")
        if [ -n "$existing_id" ]; then
            echo -e "${YELLOW}⚠ URL already exists in queue${NC}"
            echo -e "  Job ID: ${BOLD}$existing_id${NC}"
            echo -e "  URL: $url"
            echo ""
            echo -e "Use ${CYAN}prewarm add -f <url>${NC} to force add"
            exit 1
        fi
    fi
    
    local id=$(generate_id)
    local job_file="$QUEUE_DIR/$id.job"
    
    cat > "$job_file" << EOF
{
  "id": "$id",
  "url": "$url",
  "parallel": $parallel,
  "status": "pending",
  "progress": 0,
  "total": 0,
  "hit": 0,
  "miss": 0,
  "expired": 0,
  "failed": 0,
  "created": "$(timestamp)",
  "started": "",
  "completed": ""
}
EOF
    
    echo -e "${GREEN}✓ Added job: ${BOLD}$id${NC}"
    echo -e "  URL: $url"
    echo -e "  Parallel: $parallel"
    
    # Auto-start daemon if not running
    if ! is_daemon_running; then
        echo -e "${YELLOW}Starting daemon...${NC}"
        cmd_start
    fi
}

cmd_list() {
    local watch_mode=false
    [ "$1" = "-w" ] || [ "$1" = "--watch" ] && watch_mode=true
    
    if [ "$watch_mode" = true ]; then
        # Use watch command for smooth display
        watch -t -n 1 'prewarm list'
    else
        _print_list_header
        _print_list
    fi
}

_print_list_header() {
    local cols=$(tput cols 2>/dev/null || echo 80)
    echo -e "${BOLD}${CYAN}PREWARM QUEUE${NC}  $(date '+%Y-%m-%d %H:%M:%S')  ${DIM}(Ctrl+C to exit)${NC}"
    echo ""
}

_print_list() {
    local cols=$(tput cols 2>/dev/null || echo 80)
    local url_width=$((cols - 50))
    [ "$url_width" -lt 20 ] && url_width=20
    
    # Header line
    local header_line=$(printf '═%.0s' $(seq 1 $((cols - 2))))
    echo -e "${CYAN}${header_line}${NC}"
    printf "${BOLD}%-7s %-9s %8s %8s %8s  %-${url_width}s${NC}\n" "ID" "STATUS" "PROGRESS" "HIT" "MISS" "URL"
    echo -e "${CYAN}${header_line}${NC}"
    
    local has_jobs=false
    local cols=$(tput cols 2>/dev/null || echo 80)
    local url_width=$((cols - 50))
    [ "$url_width" -lt 20 ] && url_width=20
    
    # Running jobs
    shopt -s nullglob
    for job_file in "$RUNNING_DIR"/*.job; do
        [ -f "$job_file" ] || continue
        has_jobs=true
        print_job_line "$job_file" "running" "$url_width"
    done
    
    # Pending jobs
    for job_file in "$QUEUE_DIR"/*.job; do
        [ -f "$job_file" ] || continue
        has_jobs=true
        print_job_line "$job_file" "pending" "$url_width"
    done
    shopt -u nullglob
    
    if [ "$has_jobs" = false ]; then
        echo -e "${YELLOW}  No jobs in queue${NC}"
    fi
    
    local header_line=$(printf '═%.0s' $(seq 1 $((cols - 2))))
    echo -e "${CYAN}${header_line}${NC}"
    
    # Show daemon status
    if is_daemon_running; then
        local running_count=$(ls -1 "$RUNNING_DIR"/*.job 2>/dev/null | wc -l)
        echo -e "Daemon: ${GREEN}running${NC} | Concurrent: $running_count/$MAX_CONCURRENT"
    else
        echo -e "Daemon: ${RED}stopped${NC}"
    fi
}

print_job_line() {
    local job_file="$1"
    local status="$2"
    local url_width="${3:-40}"
    
    local id=$(grep -o '"id": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local url=$(grep -o '"url": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local progress=$(grep -o '"progress": [0-9]*' "$job_file" | awk '{print $2}')
    local total=$(grep -o '"total": [0-9]*' "$job_file" | awk '{print $2}')
    local hit=$(grep -o '"hit": [0-9]*' "$job_file" | awk '{print $2}')
    local miss=$(grep -o '"miss": [0-9]*' "$job_file" | awk '{print $2}')
    
    # Truncate URL to fit terminal
    local url_display="$url"
    if [ ${#url} -gt $url_width ]; then
        url_display="${url:0:$((url_width-2))}.."
    fi
    
    # Format progress
    local progress_str="-"
    if [ -n "$total" ] && [ "$total" -gt 0 ]; then
        local pct=$((progress * 100 / total))
        progress_str="${pct}%"
    fi
    
    # Status with color (fixed width output)
    case "$status" in
        running) printf "%-7s ${GREEN}%-9s${NC} %8s %8s %8s  %s\n" "$id" "running" "$progress_str" "${hit:-0}" "${miss:-0}" "$url_display" ;;
        pending) printf "%-7s ${YELLOW}%-9s${NC} %8s %8s %8s  %s\n" "$id" "pending" "$progress_str" "${hit:-0}" "${miss:-0}" "$url_display" ;;
    esac
}

cmd_status() {
    local watch_mode=false
    [ "$1" = "-w" ] || [ "$1" = "--watch" ] && watch_mode=true
    
    if [ "$watch_mode" = true ]; then
        # Use watch command for smooth display
        watch -t -n 1 'prewarm status'
    else
        _print_status
    fi
}

_print_status() {
    # Live status of running jobs
    echo -e "${BOLD}${CYAN}══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}Active Jobs${NC}"
    echo -e "${CYAN}══════════════════════════════════════════════════════════════${NC}"
    
    local has_running=false
    
    shopt -s nullglob
    for job_file in "$RUNNING_DIR"/*.job; do
        [ -f "$job_file" ] || continue
        has_running=true
        
        local id=$(grep -o '"id": "[^"]*"' "$job_file" | cut -d'"' -f4)
        local url=$(grep -o '"url": "[^"]*"' "$job_file" | cut -d'"' -f4)
        local progress=$(grep -o '"progress": [0-9]*' "$job_file" | awk '{print $2}')
        local total=$(grep -o '"total": [0-9]*' "$job_file" | awk '{print $2}')
        local hit=$(grep -o '"hit": [0-9]*' "$job_file" | awk '{print $2}')
        local miss=$(grep -o '"miss": [0-9]*' "$job_file" | awk '{print $2}')
        local expired=$(grep -o '"expired": [0-9]*' "$job_file" | awk '{print $2}')
        local started=$(grep -o '"started": "[^"]*"' "$job_file" | cut -d'"' -f4)
        
        echo -e "\n${BOLD}Job: $id${NC}"
        echo -e "URL: ${BLUE}$url${NC}"
        echo -e "Started: $started"
        
        # Progress bar
        if [ -n "$total" ] && [ "$total" -gt 0 ]; then
            local pct=$((progress * 100 / total))
            local bar_width=40
            local filled=$((pct * bar_width / 100))
            local empty=$((bar_width - filled))
            
            printf "Progress: ["
            printf "${GREEN}%${filled}s" | tr ' ' '█'
            printf "${NC}%${empty}s" | tr ' ' '░'
            printf "] %d/%d (%d%%)\n" "$progress" "$total" "$pct"
        else
            echo "Progress: Initializing..."
        fi
        
        echo -e "Cache: ${GREEN}HIT $hit${NC} | ${RED}MISS $miss${NC} | ${YELLOW}EXPIRED ${expired:-0}${NC}"
    done
    shopt -u nullglob
    
    if [ "$has_running" = false ]; then
        echo -e "\n${YELLOW}No jobs currently running${NC}"
    fi
    
    # Queue info
    local pending_count=$(ls -1 "$QUEUE_DIR"/*.job 2>/dev/null | wc -l | tr -d ' ')
    echo -e "\n${CYAN}──────────────────────────────────────────────────────────────${NC}"
    echo -e "Pending in queue: $pending_count"
}

cmd_watch() {
    # Disable set -e for this function
    set +e
    
    # htop-style display: jobs on top, live logs on bottom
    tput civis 2>/dev/null  # Hide cursor
    clear
    
    # Cleanup on Ctrl+C
    trap 'tput cnorm 2>/dev/null; clear; echo "Exited"; exit 0' INT TERM
    
    while :; do
        rows=$(tput lines 2>/dev/null) || rows=24
        cols=$(tput cols 2>/dev/null) || cols=80
        top_rows=$(( (rows - 4) / 2 ))
        bottom_rows=$(( rows - top_rows - 4 ))
        
        # Move to top
        tput cup 0 0 2>/dev/null
        
        # === TOP: Job List ===
        printf "\033[1;36mPREWARM MONITOR\033[0m  %s  \033[2mCtrl+C to exit\033[0m\033[K\n" "$(date '+%H:%M:%S')"
        printf "\033[36m"; printf '─%.0s' $(seq 1 $cols); printf "\033[0m\n"
        
        printf "\033[1m%-7s %-8s %6s %6s %6s  URL\033[0m\033[K\n" "ID" "STATUS" "PROG" "HIT" "MISS"
        
        job_count=0
        first_running_id=""
        
        # Running jobs
        for job_file in "$RUNNING_DIR"/*.job; do
            [ -f "$job_file" ] || continue
            _print_watch_job "$job_file" "running" "$cols"
            [ -z "$first_running_id" ] && first_running_id=$(basename "$job_file" .job)
            job_count=$((job_count + 1))
        done
        
        # Pending jobs
        for job_file in "$QUEUE_DIR"/*.job; do
            [ -f "$job_file" ] || continue
            [ $job_count -ge $((top_rows - 2)) ] && break
            _print_watch_job "$job_file" "pending" "$cols"
            job_count=$((job_count + 1))
        done
        
        [ $job_count -eq 0 ] && printf "\033[2m  No jobs in queue\033[0m\033[K\n"
        
        # Pad remaining top section
        i=$((job_count + 3))
        while [ $i -lt $top_rows ]; do
            printf "\033[K\n"
            i=$((i + 1))
        done
        
        # === SEPARATOR ===
        running_count=$(ls "$RUNNING_DIR"/*.job 2>/dev/null | wc -l)
        pending_count=$(ls "$QUEUE_DIR"/*.job 2>/dev/null | wc -l)
        printf "\033[36m"; printf '─%.0s' $(seq 1 $cols); printf "\033[0m\n"
        printf "\033[1mLIVE LOG\033[0m  Running: \033[32m%s\033[0m/%s  Pending: \033[33m%s\033[0m\033[K\n" "$running_count" "$MAX_CONCURRENT" "$pending_count"
        printf "\033[36m"; printf '─%.0s' $(seq 1 $cols); printf "\033[0m\n"
        
        # === BOTTOM: Live Logs ===
        log_lines=0
        if [ -n "$first_running_id" ] && [ -f "$LOG_DIR/$first_running_id.log" ]; then
            tail -n $bottom_rows "$LOG_DIR/$first_running_id.log" 2>/dev/null | while IFS= read -r logline; do
                display="${logline:0:$cols}"
                case "$logline" in
                    *✓*) printf "\033[32m%s\033[0m\033[K\n" "$display" ;;
                    *✗*) printf "\033[31m%s\033[0m\033[K\n" "$display" ;;
                    *) printf "\033[2m%s\033[0m\033[K\n" "$display" ;;
                esac
            done
        else
            printf "\033[2m  Waiting for job to start...\033[0m\033[K\n"
        fi
        
        # Clear to end of screen
        printf "\033[J"
        
        sleep 1
    done
}

_print_watch_job() {
    local job_file="$1"
    local status="$2"
    local cols="$3"
    
    local id=$(grep -o '"id": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local url=$(grep -o '"url": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local progress=$(grep -o '"progress": [0-9]*' "$job_file" | awk '{print $2}')
    local total=$(grep -o '"total": [0-9]*' "$job_file" | awk '{print $2}')
    local hit=$(grep -o '"hit": [0-9]*' "$job_file" | awk '{print $2}')
    local miss=$(grep -o '"miss": [0-9]*' "$job_file" | awk '{print $2}')
    
    local url_width=$((cols - 45))
    [ $url_width -lt 20 ] && url_width=20
    local url_display="${url:0:$url_width}"
    
    local prog_str="-"
    [ -n "$total" ] && [ "$total" -gt 0 ] && prog_str="$((progress * 100 / total))%"
    
    case "$status" in
        running) printf "%-7s ${GREEN}%-8s${NC} %6s %6s %6s  %s\n" "$id" "running" "$prog_str" "${hit:-0}" "${miss:-0}" "$url_display" ;;
        pending) printf "%-7s ${YELLOW}%-8s${NC} %6s %6s %6s  %s\n" "$id" "pending" "-" "0" "0" "$url_display" ;;
    esac
}

cmd_show() {
    local id="$1"
    
    if [ -z "$id" ]; then
        echo -e "${RED}Error: Job ID is required${NC}"
        echo "Usage: prewarm show <id>"
        exit 1
    fi
    
    # Find job file
    local job_file=""
    for dir in "$RUNNING_DIR" "$QUEUE_DIR" "$COMPLETED_DIR"; do
        if [ -f "$dir/$id.job" ]; then
            job_file="$dir/$id.job"
            break
        fi
    done
    
    if [ -z "$job_file" ]; then
        echo -e "${RED}Error: Job '$id' not found${NC}"
        exit 1
    fi
    
    # Parse and display
    echo -e "${BOLD}${CYAN}══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}Job Details: $id${NC}"
    echo -e "${CYAN}══════════════════════════════════════════════════════════════${NC}"
    
    local url=$(grep -o '"url": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local parallel=$(grep -o '"parallel": [0-9]*' "$job_file" | awk '{print $2}')
    local status=$(grep -o '"status": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local progress=$(grep -o '"progress": [0-9]*' "$job_file" | awk '{print $2}')
    local total=$(grep -o '"total": [0-9]*' "$job_file" | awk '{print $2}')
    local hit=$(grep -o '"hit": [0-9]*' "$job_file" | awk '{print $2}')
    local miss=$(grep -o '"miss": [0-9]*' "$job_file" | awk '{print $2}')
    local expired=$(grep -o '"expired": [0-9]*' "$job_file" | awk '{print $2}')
    local failed=$(grep -o '"failed": [0-9]*' "$job_file" | awk '{print $2}')
    local created=$(grep -o '"created": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local started=$(grep -o '"started": "[^"]*"' "$job_file" | cut -d'"' -f4)
    local completed=$(grep -o '"completed": "[^"]*"' "$job_file" | cut -d'"' -f4)
    
    echo -e "URL:      ${BLUE}$url${NC}"
    echo -e "Parallel: $parallel"
    echo -e "Status:   $status"
    echo ""
    echo -e "Progress: $progress / $total"
    echo -e "HIT:      ${GREEN}$hit${NC}"
    echo -e "MISS:     ${RED}$miss${NC}"
    echo -e "EXPIRED:  ${YELLOW}${expired:-0}${NC}"
    echo -e "FAILED:   ${RED}${failed:-0}${NC}"
    echo ""
    echo -e "Created:   $created"
    echo -e "Started:   ${started:--}"
    echo -e "Completed: ${completed:--}"
    
    # Show log if exists
    local log_file="$LOG_DIR/$id.log"
    if [ -f "$log_file" ]; then
        echo -e "\n${CYAN}──────────────────────────────────────────────────────────────${NC}"
        echo -e "${BOLD}Recent Log:${NC}"
        tail -20 "$log_file"
    fi
}

cmd_cancel() {
    local id="$1"
    
    if [ -z "$id" ]; then
        echo -e "${RED}Error: Job ID is required${NC}"
        echo "Usage: prewarm cancel <id>"
        exit 1
    fi
    
    # Check pending
    if [ -f "$QUEUE_DIR/$id.job" ]; then
        rm -f "$QUEUE_DIR/$id.job"
        echo -e "${GREEN}✓ Cancelled pending job: $id${NC}"
        return 0
    fi
    
    # Check running
    if [ -f "$RUNNING_DIR/$id.job" ]; then
        # Find and kill worker process
        local pid_file="$RUNNING_DIR/$id.pid"
        if [ -f "$pid_file" ]; then
            local pid=$(cat "$pid_file")
            kill "$pid" 2>/dev/null || true
            rm -f "$pid_file"
        fi
        rm -f "$RUNNING_DIR/$id.job"
        echo -e "${GREEN}✓ Cancelled running job: $id${NC}"
        return 0
    fi
    
    echo -e "${RED}Error: Job '$id' not found${NC}"
    exit 1
}

cmd_remove() {
    local id="$1"
    
    if [ -z "$id" ]; then
        echo -e "${RED}Error: Job ID is required${NC}"
        echo "Usage: prewarm remove <id>"
        echo "       prewarm remove all       # Remove all completed jobs"
        echo "       prewarm remove pending   # Remove all pending jobs"
        exit 1
    fi
    
    case "$id" in
        all)
            # Remove all completed jobs
            local count=$(ls -1 "$COMPLETED_DIR"/*.job 2>/dev/null | wc -l)
            rm -f "$COMPLETED_DIR"/*.job
            rm -f "$LOG_DIR"/*.log 2>/dev/null || true
            echo -e "${GREEN}✓ Removed $count completed jobs${NC}"
            ;;
        pending)
            # Remove all pending jobs
            local count=$(ls -1 "$QUEUE_DIR"/*.job 2>/dev/null | wc -l)
            rm -f "$QUEUE_DIR"/*.job
            echo -e "${GREEN}✓ Removed $count pending jobs${NC}"
            ;;
        *)
            # Remove specific job
            local found=false
            
            # Check completed
            if [ -f "$COMPLETED_DIR/$id.job" ]; then
                rm -f "$COMPLETED_DIR/$id.job"
                rm -f "$LOG_DIR/$id.log" 2>/dev/null || true
                found=true
            fi
            
            # Check pending
            if [ -f "$QUEUE_DIR/$id.job" ]; then
                rm -f "$QUEUE_DIR/$id.job"
                found=true
            fi
            
            # Check running (cancel first)
            if [ -f "$RUNNING_DIR/$id.job" ]; then
                cmd_cancel "$id"
                found=true
            fi
            
            if [ "$found" = true ]; then
                echo -e "${GREEN}✓ Removed job: $id${NC}"
            else
                echo -e "${RED}Error: Job '$id' not found${NC}"
                exit 1
            fi
            ;;
    esac
}

cmd_config() {
    local key="$1"
    local value="$2"
    
    if [ -z "$key" ]; then
        echo -e "${BOLD}Current Configuration:${NC}"
        echo -e "  MAX_CONCURRENT=$MAX_CONCURRENT  (จำนวน job ที่รันพร้อมกัน)"
        echo -e "  DEFAULT_PARALLEL=$DEFAULT_PARALLEL  (parallel requests per job)"
        echo -e "  BASE_DOMAIN=$BASE_DOMAIN"
        echo -e "  API_ENDPOINT=$API_ENDPOINT"
        echo -e "  API_TOKEN=${API_TOKEN:+***hidden***}"
        echo ""
        echo "Usage: prewarm config <key> <value>"
        echo "       prewarm setup  (interactive setup)"
        echo ""
        echo "Example: prewarm config MAX_CONCURRENT 3"
        return 0
    fi
    
    if [ -z "$value" ]; then
        echo -e "${RED}Error: Value is required${NC}"
        exit 1
    fi
    
    # Update config
    if grep -q "^$key=" "$CONFIG_FILE"; then
        sed -i "s/^$key=.*/$key=$value/" "$CONFIG_FILE"
    else
        echo "$key=$value" >> "$CONFIG_FILE"
    fi
    
    echo -e "${GREEN}✓ Set $key=$value${NC}"
    
    # Reload if daemon is running
    if is_daemon_running; then
        echo -e "${YELLOW}Restart daemon to apply changes: prewarm restart${NC}"
    fi
}

cmd_start() {
    if is_daemon_running; then
        echo -e "${YELLOW}Daemon is already running (PID: $(cat "$PID_FILE"))${NC}"
        return 0
    fi
    
    # Start daemon
    nohup "$(dirname "$0")/prewarm-daemon" >> "$LOG_DIR/daemon.log" 2>&1 &
    echo $! > "$PID_FILE"
    
    sleep 1
    
    if is_daemon_running; then
        echo -e "${GREEN}✓ Daemon started (PID: $(cat "$PID_FILE"))${NC}"
    else
        echo -e "${RED}✗ Failed to start daemon${NC}"
        exit 1
    fi
}

cmd_stop() {
    if ! is_daemon_running; then
        echo -e "${YELLOW}Daemon is not running${NC}"
        return 0
    fi
    
    local pid=$(cat "$PID_FILE")
    kill "$pid" 2>/dev/null
    rm -f "$PID_FILE"
    
    echo -e "${GREEN}✓ Daemon stopped${NC}"
}

cmd_restart() {
    cmd_stop
    sleep 1
    cmd_start
}

is_daemon_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p "$pid" > /dev/null 2>&1; then
            return 0
        fi
    fi
    return 1
}

cmd_logs() {
    local id="$1"
    
    if [ -z "$id" ]; then
        # Show daemon log
        tail -f "$LOG_DIR/daemon.log"
    else
        # Show job log
        local log_file="$LOG_DIR/$id.log"
        if [ -f "$log_file" ]; then
            tail -f "$log_file"
        else
            echo -e "${RED}Error: Log for job '$id' not found${NC}"
            exit 1
        fi
    fi
}

cmd_clean() {
    local hours="${1:-1}"
    local mins=$((hours * 60))
    
    # Clean completed jobs older than X hours
    local job_count=$(find "$COMPLETED_DIR" -name "*.job" -mmin +$mins 2>/dev/null | wc -l)
    find "$COMPLETED_DIR" -name "*.job" -mmin +$mins -delete 2>/dev/null
    
    # Clean logs older than 24 hours
    local log_count=$(find "$LOG_DIR" -name "*.log" -mmin +1440 2>/dev/null | wc -l)
    find "$LOG_DIR" -name "*.log" -mmin +1440 -delete 2>/dev/null
    
    echo -e "${GREEN}✓ Cleaned $job_count jobs (older than ${hours}h) and $log_count logs${NC}"
}

cmd_purge() {
    echo -e "${YELLOW}This will remove ALL jobs (pending, running, completed) and logs${NC}"
    echo -n "Are you sure? [y/N] "
    read -r confirm
    
    if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
        # Stop daemon first
        cmd_stop 2>/dev/null || true
        
        # Remove all jobs
        rm -f "$QUEUE_DIR"/*.job 2>/dev/null
        rm -f "$RUNNING_DIR"/*.job 2>/dev/null
        rm -f "$RUNNING_DIR"/*.pid 2>/dev/null
        rm -f "$COMPLETED_DIR"/*.job 2>/dev/null
        rm -f "$LOG_DIR"/*.log 2>/dev/null
        
        echo -e "${GREEN}✓ Purged all jobs and logs${NC}"
    else
        echo "Cancelled"
    fi
}

cmd_help() {
    echo -e "${BOLD}Prewarm CLI - HLS Cache Warming Queue${NC}"
    echo ""
    echo "Usage: prewarm <command> [options]"
    echo ""
    echo -e "${BOLD}Setup:${NC}"
    echo "  setup                 Configure BASE_DOMAIN, API_ENDPOINT"
    echo ""
    echo -e "${BOLD}Job Commands:${NC}"
    echo "  add <url|id> [parallel]  Add URL or ID to queue"
    echo "  list [-w]             List all jobs (-w for watch mode)"
    echo "  status [-w]           Show running jobs status (-w for watch mode)"
    echo "  watch                 Real-time status (same as status -w)"
    echo "  show <id>             Show job details"
    echo "  cancel <id>           Cancel a running/pending job"
    echo "  remove <id>           Remove a job from queue"
    echo "  remove all            Remove all completed jobs"
    echo "  remove pending        Remove all pending jobs"
    echo "  logs [id]             Show logs (daemon or job)"
    echo "  fetch                 Fetch queue from API endpoint"
    echo ""
    echo -e "${BOLD}Daemon:${NC}"
    echo "  start                 Start daemon"
    echo "  stop                  Stop daemon"
    echo "  restart               Restart daemon"
    echo ""
    echo -e "${BOLD}Config & Cleanup:${NC}"
    echo "  config                Show current config"
    echo "  config <key> <value>  Set config value"
    echo "  clean [hours]         Clean completed jobs older than X hours (default: 1)"
    echo "  purge                 Remove ALL jobs and logs"
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo "  prewarm setup"
    echo "  prewarm add h_A8yW-KTJql3           # Add by ID (uses BASE_DOMAIN)"
    echo "  prewarm add https://example.com/master.m3u8"
    echo "  prewarm add h_A8yW-KTJql3 50        # With parallel count"
    echo "  prewarm fetch                       # Fetch jobs from API"
    echo "  prewarm config MAX_CONCURRENT 3"
}

# Fetch command
cmd_fetch() {
    if [ -z "$API_ENDPOINT" ]; then
        echo -e "${RED}Error: API_ENDPOINT not configured${NC}"
        echo "Run 'prewarm setup' first"
        exit 1
    fi
    
    echo -e "${CYAN}Fetching queue from API...${NC}"
    
    local auth_header=""
    if [ -n "$API_TOKEN" ]; then
        auth_header="-H \"Authorization: Bearer $API_TOKEN\""
    fi
    
    # Fetch from API
    local response=$(curl -s -X GET "$API_ENDPOINT/queue" \
        -H "Content-Type: application/json" \
        $auth_header 2>/dev/null || echo "")
    
    if [ -z "$response" ] || [ "$response" = "[]" ]; then
        echo -e "${YELLOW}No jobs in API queue${NC}"
        return 0
    fi
    
    local added=0
    
    # Parse JSON array and add jobs
    # Expected format: [{"id": "xxx", "parallel": 20}, ...]
    echo "$response" | grep -oP '\{[^}]+\}' | while read -r job; do
        local job_id=$(echo "$job" | grep -oP '"id"\s*:\s*"\K[^"]+')
        local parallel=$(echo "$job" | grep -oP '"parallel"\s*:\s*\K[0-9]+')
        
        if [ -n "$job_id" ]; then
            echo -e "  Adding: $job_id"
            cmd_add "$job_id" "${parallel:-$DEFAULT_PARALLEL}" 2>/dev/null && added=$((added + 1)) || true
        fi
    done
    
    echo -e "${GREEN}✓ Fetched jobs from API${NC}"
}

# ============================================
# Main
# ============================================

init_dirs

case "${1:-}" in
    setup)    cmd_setup ;;
    add)      shift; cmd_add "$@" ;;
    list|ls)  cmd_list "$2" ;;
    status)   cmd_status "$2" ;;
    watch|w)  cmd_watch ;;
    show)     cmd_show "$2" ;;
    cancel)   cmd_cancel "$2" ;;
    remove|rm) cmd_remove "$2" ;;
    config)   cmd_config "$2" "$3" ;;
    fetch)    cmd_fetch ;;
    start)    cmd_start ;;
    stop)     cmd_stop ;;
    restart)  cmd_restart ;;
    logs)     cmd_logs "$2" ;;
    clean)    cmd_clean "$2" ;;
    purge)    cmd_purge ;;
    help|--help|-h|"") cmd_help ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        cmd_help
        exit 1
        ;;
esac
